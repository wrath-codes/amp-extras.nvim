local M = {}

local amptab = require("amp_extras.amptab")
local cache = require("amp_extras.amptab.cache")

-- Debounce state
local last_request_time = 0
local DEBOUNCE_MS = 500 -- Only request if 500ms since last keystroke

function M:get_trigger_characters()
  return {} -- No auto-trigger, relies on blink.cmp's default behavior
end

---@param context blink.cmp.Context|nil
---@return boolean
function M:enabled(context)
  if not amptab.config.enabled then
    return false
  end

  local bufnr = context and context.bufnr or vim.api.nvim_get_current_buf()
  local ft = vim.bo[bufnr].filetype
  local excluded = { "TelescopePrompt", "nofile", "help", "qf" }
  for _, ex in ipairs(excluded) do
    if ft == ex then
      return false
    end
  end

  return true
end

---@param context blink.cmp.Context
function M:get_completions(context, callback)
  -- Simple debounce: skip if too recent
  local now = vim.loop.now()
  if now - last_request_time < DEBOUNCE_MS then
    callback()
    return function() end
  end
  last_request_time = now
  
  local cancel_fn = amptab.complete(function(completion, err)
    if err then
      vim.notify("[AmpTab] " .. err, vim.log.levels.WARN)
      callback()
      return
    end

    if not completion or completion.text == "" then
      callback()
      return
    end

    -- The model returns the full editable region with modifications.
    local full_text = completion.text:gsub("%s+$", "")
    
    if full_text == "" then
      callback()
      return
    end
    
    -- Extract just the NEW portion for display (strip unchanged prefix/suffix)
    local prefix = completion.prefix_in_region or ""
    local suffix = completion.suffix_in_region or ""
    
    -- Find longest common suffix
    local suffix_match_len = 0
    local min_suffix_len = math.min(#suffix, #full_text)
    for i = 1, min_suffix_len do
      local suffix_pos = #suffix - i + 1
      local completed_pos = #full_text - i + 1
      if suffix:byte(suffix_pos) == full_text:byte(completed_pos) then
        suffix_match_len = i
      else
        break
      end
    end
    
    -- Find longest common prefix
    local prefix_match_len = 0
    local max_prefix_check = #full_text - suffix_match_len
    local min_prefix_len = math.min(#prefix, max_prefix_check)
    for i = 1, min_prefix_len do
      if prefix:byte(i) == full_text:byte(i) then
        prefix_match_len = i
      else
        break
      end
    end
    
    -- The "new" portion for display
    local display_text = full_text:sub(prefix_match_len + 1, #full_text - suffix_match_len)
    display_text = display_text:gsub("%s+$", "")
    
    if display_text == "" then
      callback()
      return
    end

    -- For label, show first line of the NEW portion only
    local first_line = display_text:match("^([^\n]*)") or display_text
    local label = first_line:gsub("^%s+", "") -- trim leading for display only
    if #label > 60 then
      label = label:sub(1, 57) .. "..."
    end
    
    -- Count additional lines in new portion
    local line_count = select(2, display_text:gsub("\n", "\n")) + 1
    if line_count > 1 then
      label = label .. " (+" .. (line_count - 1) .. " lines)"
    end

    -- Use textEdit to replace the entire editable region
    -- This handles both insertions and rewrites of existing code
    local item = {
      label = label,
      kind = 15, -- Snippet
      insertTextFormat = 1,
      textEdit = {
        newText = full_text,
        range = {
          start = { line = completion.range_start.row, character = completion.range_start.col },
          ["end"] = { line = completion.range_end.row, character = completion.range_end.col },
        },
      },
      labelDetails = {
        description = "⚡ AmpTab",
      },
      documentation = {
        kind = "markdown",
        value = "**⚡ AmpTab AI Completion**\n\n```" .. (vim.bo.filetype or "") .. "\n" .. display_text .. "\n```",
      },
      -- Store full_text for the actual replacement
      data = { full_text = full_text, completion = completion },
      sortText = "0000",
    }
    
    -- Add to cache for navigation
    cache.add({
      text = display_text,
      full_text = full_text,
      range_start = completion.range_start,
      range_end = completion.range_end,
      cursor_row = completion.cursor_row,
      cursor_col = completion.cursor_col,
    }, "cursor")

    callback {
      is_incomplete_forward = false,
      is_incomplete_backward = false,
      items = { item },
    }
  end)

  return function()
    if cancel_fn then
      cancel_fn()
    end
  end
end

function M.new()
  return setmetatable({}, { __index = M })
end

return M
